{"version":3,"sources":["battle/main.js","index.js"],"names":["FIELD_SIZE","CELL_VALUES","BattleField","props","state","markUp","field","currentUnit","position","x","y","direction","battleSide","size","speed","svgContainer","width","height","viewBox","path","_handleCellClick","bind","_findPath","event","target","tagName","dataset","col","row","this","coord","unitState","Object","assign","setState","virtualMarkup","coords","virtualField","currentUnitPos","currentUnitSpeed","currentUnitSide","positionOffset","j","currentRow","i","oneSideDistance","xCoordinate","push","forEach","item","split","currentUnitSize","length","_setMovableCells","_setVirtualField","rowClass","cellClassName","key","data-row","data-col","className","d","_makeMarkUp","prevProps","prevState","currentPos","prevPos","onClick","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.11172e5b.chunk.js","sourcesContent":["import React from 'react';\r\nimport './field/main.css';\r\n\r\nconst FIELD_SIZE = {\r\n  COLUMNS: 15,\r\n  ROWS: 11\r\n}\r\n\r\nconst CELL_VALUES = {\r\n  EMPTY: 0,\r\n  UNIT: 1,\r\n  BIG_UNIT: 2,\r\n  WALL: 3,\r\n  MOVE: 4\r\n}\r\n\r\nclass BattleField extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      markUp: [],\r\n      field: [],\r\n      currentUnit: {\r\n        position: {\r\n          x: 1,\r\n          y: 1\r\n        },\r\n        direction: 'right',\r\n        battleSide: 'left',\r\n        size: 2,\r\n        speed: 3\r\n      }\r\n    };\r\n\r\n    this.svgContainer = {\r\n      width: '61',\r\n      height: '70',\r\n      viewBox: '0 0 60.6217782649107 70',\r\n      path: 'M30.31088913245535 0L60.6217782649107 17.5L60.6217782649107 52.5L30.31088913245535 70L0 52.5L0 17.5Z'\r\n    };\r\n\r\n    this._handleCellClick = this._handleCellClick.bind(this);\r\n    this._findPath = this._findPath.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Обработчик клика по ячейке поля\r\n   * @param {Event} event \r\n   */\r\n  _handleCellClick(event) {\r\n    if (event.target.tagName !== 'svg') {\r\n      return;\r\n    }\r\n    const dataset = event.target.dataset;\r\n    let x = +dataset.col;\r\n    const y = +dataset.row;\r\n    const row = this.state.field[y-1];\r\n    const coord = row[x-1];\r\n\r\n    // игнорирование занятых клеток\r\n    if (coord === CELL_VALUES.EMPTY || coord === CELL_VALUES.UNIT) {\r\n      return;\r\n    }\r\n\r\n    const unitState = this.state.currentUnit;\r\n    const unitXCoordinate = unitState.position.x;\r\n    const direction = unitXCoordinate - x > 0 ? 'left' : 'right';\r\n\r\n    if (unitState.size === CELL_VALUES.BIG_UNIT) {\r\n      if (unitState.battleSide === 'left' && direction === 'right') {\r\n        if (row[x] !== CELL_VALUES.MOVE) {\r\n          x--;\r\n        }\r\n      } else {\r\n        // x = row[x-CELL_VALUES.BIG_UNIT] !== CELL_VALUES.MOVE ? x + 1 : x; \r\n      }\r\n    }\r\n\r\n    const currentUnit = Object.assign({}, this.state.currentUnit, {position: {x, y}, direction});\r\n    \r\n    this._findPath(x, y);\r\n\r\n    this.setState({\r\n      currentUnit\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Поиск пути\r\n   * @param {string} x - начальная координата по оси x \r\n   * @param {string} y - начальная координата по оси y \r\n   */\r\n  _findPath(x, y) {\r\n    // const reachebleCells = [];\r\n  }\r\n\r\n  /**\r\n   * Отображение клеток, доступных для перемещения\r\n   * @param {Array} virtualMarkup \r\n   */\r\n  _setMovableCells(virtualMarkup) {\r\n    let coords = [];\r\n    const virtualField = virtualMarkup;\r\n    const currentUnit = this.state.currentUnit;\r\n    const currentUnitPos = currentUnit.position;\r\n    const currentUnitSpeed = currentUnit.speed;\r\n    const currentUnitSide = currentUnit.battleSide;\r\n\r\n    let positionOffset = 0;\r\n\r\n    for (let j = 0; j <= currentUnitSpeed; j++) {\r\n      const currentRow = currentUnitPos.y + j;\r\n\r\n      // сдвиг начала доступных для перемещения клеток в строке\r\n      // так как поле сделано из гексов, то каждая вторая строка сдвигается на одну клетку относительно самой крайней клетки\r\n      if (currentRow !== currentUnitPos.y && currentRow % 2 !== 0) {\r\n        positionOffset++;\r\n      }\r\n\r\n      for (let i = 0; i < currentUnitSpeed * 2 + currentUnit.size - j; i++) {\r\n        const oneSideDistance = currentUnitSpeed + (currentUnitSide === 'left' ? currentUnit.size - 1 : 0);\r\n        const xCoordinate = (i > oneSideDistance ? currentUnitPos.x - i + oneSideDistance : currentUnitPos.x + i) - positionOffset;\r\n        coords.push(`${xCoordinate} ${currentRow}`);\r\n        \r\n        if (currentRow !== currentRow - j * 2) {\r\n          coords.push(`${xCoordinate} ${currentRow - j * 2}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    coords.forEach((item) => {\r\n      const y = +item.split(' ')[1];\r\n      const x = +item.split(' ')[0];\r\n      const isCorrectCoordinate = x > 0 && x <= FIELD_SIZE.COLUMNS && y > 0 && y <= FIELD_SIZE.ROWS;\r\n\r\n      if (isCorrectCoordinate && virtualField[y - 1][x - 1] === CELL_VALUES.EMPTY) {\r\n        virtualField[y - 1][x - 1] = CELL_VALUES.MOVE;\r\n      }\r\n    });\r\n\r\n    return virtualField;\r\n  }\r\n\r\n  /**\r\n   * Заполнение виртуального поля\r\n   * @param {Array} virtualMarkup \r\n   */\r\n  _setVirtualField() {\r\n    let field = [];\r\n    const currentUnit = this.state.currentUnit;\r\n    const currentUnitPos = currentUnit.position;\r\n    const currentUnitSide = currentUnit.battleSide;\r\n    const currentUnitSize = currentUnit.size;\r\n\r\n    for (let i = 0; i < FIELD_SIZE.ROWS; i++) {\r\n      field.push([]);\r\n\r\n      for (let j = 0; j < FIELD_SIZE.COLUMNS; j++) {\r\n        if (i === currentUnitPos.y - 1 && j === currentUnitPos.x - 1) {\r\n          field[i].push(currentUnitSize);\r\n\r\n          /**\r\n           * если юнит большой, то надо заполнять +1 ячейку под него\r\n           * при этом надо учитывать направление и сторону юнита на поле\r\n           * и размещать доп. клетку слева или справа в зависимости от стороны\r\n           */\r\n          if (currentUnitSize === CELL_VALUES.BIG_UNIT) {\r\n            currentUnitSide === 'left' ? field[i].push(currentUnitSize) : field[i][field[i].length - currentUnitSize] = currentUnitSize;\r\n          }\r\n        } else {\r\n          field[i].push(CELL_VALUES.EMPTY);\r\n        }\r\n      }\r\n    }\r\n\r\n    field = this._setMovableCells(field);\r\n\r\n    return field;\r\n  }\r\n\r\n  /**\r\n   * Создание разметки поля боя, виртуальной и физической\r\n   */\r\n  _makeMarkUp() {\r\n    const markUp = [];\r\n    const field = this._setVirtualField();\r\n\r\n    for (let i = 1; i <= FIELD_SIZE.ROWS; i++) {\r\n      const row = [];\r\n      const rowClass = `battlefield_row battlefield_row--${i % 2 === 0 ? 'even' : 'odd'}`;\r\n\r\n      for (let j = 1; j <= FIELD_SIZE.COLUMNS; j++) {\r\n        let cellClassName = \"battlefield_cell\";\r\n        \r\n        switch (field[i-1][j-1]) {\r\n          case CELL_VALUES.UNIT:\r\n          case CELL_VALUES.BIG_UNIT:\r\n            cellClassName += ` ${cellClassName}--currentUnit`;\r\n            break;\r\n          case CELL_VALUES.MOVE:\r\n            cellClassName += ` ${cellClassName}--movable`;\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n\r\n        row.push(<svg key={`cell_${i}-${j}`}\r\n                      data-row={i}\r\n                      data-col={j}\r\n                      className={cellClassName}\r\n                      width={this.svgContainer.width}\r\n                      height={this.svgContainer.height}\r\n                      viewBox={this.svgContainer.viewBox}>\r\n                        <path d={this.svgContainer.path}></path>\r\n                  </svg>);\r\n      }\r\n      markUp.push(<div key={`row_${i}`} className={rowClass}>{row}</div>);\r\n    };\r\n    \r\n    return  {markUp, field};\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.setState(this._makeMarkUp());\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const currentPos = this.state.currentUnit.position;\r\n    const prevPos = prevState.currentUnit.position;\r\n\r\n    if (currentPos.x !== prevPos.x || currentPos.y !== prevPos.y) {\r\n      this.setState(this._makeMarkUp());\r\n    }\r\n  }\r\n\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"battleField_main\" onClick={this._handleCellClick}>\r\n        {this.state.markUp}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BattleField;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport BattleField from './battle/main';\n\nReactDOM.render(<BattleField />, document.getElementById('root'));\n"],"sourceRoot":""}